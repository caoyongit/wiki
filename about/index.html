
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-8.5.8">
    
    
      
        <title>About - Java Architect</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.20d9efc8.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.815d1a91.min.css">
        
          
          
          <meta name="theme-color" content="#4cae4f">
        
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="green" data-md-color-accent="green">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href=".." title="Java Architect" class="md-header__button md-logo" aria-label="Java Architect" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Java Architect
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              About
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  
  


  <li class="md-tabs__item">
    <a href=".." class="md-tabs__link">
      Home
    </a>
  </li>

      
        
  
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/Spring/Spring%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/" class="md-tabs__link">
        Java源码系列
      </a>
    </li>
  

  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../license.md" class="md-tabs__link">
        Ngnix
      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Java Architect" class="md-nav__button md-logo" aria-label="Java Architect" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Java Architect
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          Java源码系列
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Java源码系列" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          Java源码系列
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_1" type="checkbox" id="__nav_2_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2_1">
          Spring
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Spring" data-md-level="2">
        <label class="md-nav__title" for="__nav_2_1">
          <span class="md-nav__icon md-icon"></span>
          Spring
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/Spring/Spring%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/" class="md-nav__link">
        Spring源码编译教程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/Spring/Spring%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/" class="md-nav__link">
        1.Spring核心知识点
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/Spring/%E6%89%8B%E5%86%99%E6%A8%A1%E6%8B%9FSpring%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="md-nav__link">
        2.手写模拟Spring底层原理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/Spring/Spring%E4%B9%8B%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90/" class="md-nav__link">
        3.Spring之底层架构核心概念解析
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../styling-your-docs.md" class="md-nav__link">
        MyBatis
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          Ngnix
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Ngnix" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          Ngnix
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../license.md" class="md-nav__link">
        License
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../release-notes.md" class="md-nav__link">
        Release Notes
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  <h1>About</h1>

<p>有道云链接：http://note.youdao.com/noteshare? id=663444a188ed9057dffd07cfbeed43cc&amp;sub=D6060DA6961E42D699A3B7DDB2118F93（ 复制链接到浏览器的时候注意转行的空格哦） 作者：周瑜 前面两节课，我们大概了解了Spring中的一些概念和底层工作流程，本节课开始将真正讲一些Spring 中的概念和工作流程。 本节课的内容，是后续看Spring源码所必备的，防止后续看源码的过程中，遇到不会的概念得单独跳 出来学习。 BeanDefinition BeanDefinition表示Bean定义，BeanDefinition中存在很多属性用来描述一个Bean的特点。比如： class，表示Bean类型 scope，表示Bean作用域，单例或原型等 lazyInit：表示Bean是否是懒加载 initMethodName：表示Bean初始化时要执行的方法 destroyMethodName：表示Bean销毁时要执行的方法 还有很多... 在Spring中，我们经常会通过以下几种方式来定义Bean： 1.  2. @Bean 3. @Component(@Service,@Controller) 这些，我们可以称之申明式定义Bean。 我们还可以编程式定义Bean，那就是直接通过BeanDefinition，比如： AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); // 生成一个BeanDefinition对象，并设置beanClass为User.class，并注册到ApplicationContext中 AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition(); beanDefinition.setBeanClass(User.class); context.registerBeanDefinition("user", beanDefinition); System.out.println(context.getBean("user")); 我们还可以通过BeanDefinition设置一个Bean的其他属性 beanDefinition.setScope("prototype"); // 设置作用域 beanDefinition.setInitMethodName("init"); // 设置初始化方法 beanDefinition.setLazyInit(true); // 设置懒加载 和申明式事务、编程式事务类似，通过，@Bean，@Component等申明式方式所定义的 Bean，最终都会被Spring解析为对应的BeanDefinition对象，并放入Spring容器中。 BeanDefinitionReader 接下来，我们来介绍几种在Spring源码中所提供的BeanDefinition读取器 （BeanDefinitionReader），这些BeanDefinitionReader在我们使用Spring时用得少，但在Spring 源码中用得多，相当于Spring源码的基础设施。 AnnotatedBeanDefinitionReader 可以直接把某个类转换为BeanDefinition，并且会解析该类上的注解，比如 AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); AnnotatedBeanDefinitionReader annotatedBeanDefinitionReader = new AnnotatedBeanDefinitionReader(context); // 将User.class解析为BeanDefinition annotatedBeanDefinitionReader.register(User.class); System.out.println(context.getBean("user")); 注意：它能解析的注解是：@Conditional，@Scope、@Lazy、@Primary、@DependsOn、 @Role、@Description XmlBeanDefinitionReader 可以解析标签 AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(context); int i = xmlBeanDefinitionReader.loadBeanDefinitions("spring.xml"); System.out.println(context.getBean("user")); ClassPathBeanDefinitionScanner ClassPathBeanDefinitionScanner ClassPathBeanDefinitionScanner是扫描器，但是它的作用和BeanDefinitionReader类似，它可以 进行扫描，扫描某个包路径，对扫描到的类进行解析，比如，扫描到的类上如果存在@Component 注解，那么就会把这个类解析为一个BeanDefinition，比如： AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); context.refresh(); ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(context); scanner.scan("com.zhouyu"); System.out.println(context.getBean("userService")); BeanFactory BeanFactory表示Bean工厂，所以很明显，BeanFactory会负责创建Bean，并且提供获取Bean的 API。 而ApplicationContext是BeanFactory的一种，在Spring源码中，是这么定义的： public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver { ... } 首先，在Java中，接口是可以多继承的，我们发现ApplicationContext继承了ListableBeanFactory 和HierarchicalBeanFactory，而ListableBeanFactory和HierarchicalBeanFactory都继承至 BeanFactory，所以我们可以认为ApplicationContext继承了BeanFactory，相当于苹果继承水果， 宝马继承汽车一样，ApplicationContext也是BeanFactory的一种，拥有BeanFactory支持的所有功 能，不过ApplicationContext比BeanFactory更加强大，ApplicationContext还基础了其他接口，也 就表示ApplicationContext还拥有其他功能，比如MessageSource表示国际化， ApplicationEventPublisher表示事件发布，EnvironmentCapable表示获取环境变量，等等，关于 ApplicationContext后面再详细讨论。 在Spring的源码实现中，当我们new一个ApplicationContext时，其底层会new一个BeanFactory出 来，当使用ApplicationContext的某些方法时，比如getBean()，底层调用的是BeanFactory的 getBean()方法。 在Spring源码中，BeanFactory接口存在一个非常重要的实现类是： <strong>DefaultListableBeanFactory，也是非常核心的。</strong>具体重要性，随着后续课程会感受更深。 所以，我们可以直接来使用DefaultListableBeanFactory，而不用使用ApplicationContext的某个 实现类，比如： DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition(); beanDefinition.setBeanClass(User.class); beanFactory.registerBeanDefinition("user", beanDefinition); System.out.println(beanFactory.getBean("user")); DefaultListableBeanFactory是非常强大的，支持很多功能，可以通过查看 DefaultListableBeanFactory的类继承实现结构来看 这部分现在看不懂没关系，源码熟悉一点后回来再来看都可以。 它实现了很多接口，表示，它拥有很多功能： 1. AliasRegistry：支持别名功能，一个名字可以对应多个别名 2. BeanDefinitionRegistry：可以注册、保存、移除、获取某个BeanDefinition 3. BeanFactory：Bean工厂，可以根据某个bean的名字、或类型、或别名获取某个Bean对象 4. SingletonBeanRegistry：可以直接注册、获取某个单例Bean 5. SimpleAliasRegistry：它是一个类，实现了AliasRegistry接口中所定义的功能，支持别名功能 6. ListableBeanFactory：在BeanFactory的基础上，增加了其他功能，可以获取所有 BeanDefinition的beanNames，可以根据某个类型获取对应的beanNames，可以根据某个类 型获取{类型：对应的Bean}的映射关系 7. HierarchicalBeanFactory：在BeanFactory的基础上，添加了获取父BeanFactory的功能 8. DefaultSingletonBeanRegistry：它是一个类，实现了SingletonBeanRegistry接口，拥有了直 接注册、获取某个单例Bean的功能 9. ConfigurableBeanFactory：在HierarchicalBeanFactory和SingletonBeanRegistry的基础上， 添加了设置父BeanFactory、类加载器（表示可以指定某个类加载器进行类的加载）、设置 Spring EL表达式解析器（表示该BeanFactory可以解析EL表达式）、设置类型转化服务（表示 该BeanFactory可以进行类型转化）、可以添加BeanPostProcessor（表示该BeanFactory支持 Bean的后置处理器），可以合并BeanDefinition，可以销毁某个Bean等等功能 10. FactoryBeanRegistrySupport：支持了FactoryBean的功能 11. AutowireCapableBeanFactory：是直接继承了BeanFactory，在BeanFactory的基础上，支持 在创建Bean的过程中能对Bean进行自动装配 12. AbstractBeanFactory：实现了ConfigurableBeanFactory接口，继承了 FactoryBeanRegistrySupport，这个BeanFactory的功能已经很全面了，但是不能自动装配和 获取beanNames 13. ConfigurableListableBeanFactory：继承了ListableBeanFactory、 AutowireCapableBeanFactory、ConfigurableBeanFactory 14. AbstractAutowireCapableBeanFactory：继承了AbstractBeanFactory，实现了 AutowireCapableBeanFactory，拥有了自动装配的功能 15. DefaultListableBeanFactory：继承了AbstractAutowireCapableBeanFactory，实现了 ConfigurableListableBeanFactory接口和BeanDefinitionRegistry接口，所以 DefaultListableBeanFactory的功能很强大 ApplicationContext 上面有分析到，ApplicationContext是个接口，实际上也是一个BeanFactory，不过比BeanFactory 更加强大，比如： 1. HierarchicalBeanFactory：拥有获取父BeanFactory的功能 2. ListableBeanFactory：拥有获取beanNames的功能 3. ResourcePatternResolver：资源加载器，可以一次性获取多个资源（文件资源等等） 4. EnvironmentCapable：可以获取运行时环境（没有设置运行时环境功能） 5. ApplicationEventPublisher：拥有广播事件的功能（没有添加事件监听器的功能） 6. MessageSource：拥有国际化功能 具体的功能演示，后面会有。 我们先来看ApplicationContext两个比较重要的实现类： 1. AnnotationConfigApplicationContext 2. ClassPathXmlApplicationContext AnnotationConfigApplicationContext 这部分现在看不懂没关系，源码熟悉一点后回来再来看都可以。 1. ConfigurableApplicationContext：继承了ApplicationContext接口，增加了，添加事件监听 器、添加BeanFactoryPostProcessor、设置Environment，获取 ConfigurableListableBeanFactory等功能 2. AbstractApplicationContext：实现了ConfigurableApplicationContext接口 3. GenericApplicationContext：继承了AbstractApplicationContext，实现了 BeanDefinitionRegistry接口，拥有了所有ApplicationContext的功能，并且可以注册 BeanDefinition，注意这个类中有一个属性(DefaultListableBeanFactory beanFactory) 4. AnnotationConfigRegistry：可以单独注册某个为类为BeanDefinition（可以处理该类上的 <strong>@Configuration注解</strong>，已经可以处理<strong>@Bean注解</strong>），同时可以扫描 5. AnnotationConfigApplicationContext：继承了GenericApplicationContext，实现了 AnnotationConfigRegistry接口，拥有了以上所有的功能 ClassPathXmlApplicationContext 它也是继承了AbstractApplicationContext，但是相对于AnnotationConfigApplicationContext而 言，功能没有AnnotationConfigApplicationContext强大，比如不能注册BeanDefinition 国际化 先定义一个MessageSource: @Bean public MessageSource messageSource() { ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); messageSource.setBasename("messages"); return messageSource; } 有了这个Bean，你可以在你任意想要进行国际化的地方使用该MessageSource。 同时，因为 ApplicationContext也拥有国家化的功能，所以可以直接这么用： context.getMessage("test", null, new Locale("en_CN")) 资源加载 ApplicationContext还拥有资源加载的功能，比如，可以直接利用ApplicationContext获取某个文 件的内容： AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); Resource resource = context.getResource("file://D:\IdeaProjects\spring‐ framework\luban\src\main\java\com\luban\entity\User.java"); System.out.println(resource.contentLength()); 你可以想想，如果你不使用ApplicationContext，而是自己来实现这个功能，就比较费时间了。 还比如你可以： AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); Resource resource = context.getResource("file://D:\IdeaProjects\spring‐framework‐ 5.3.10\tuling\src\main\java\com\zhouyu\service\UserService.java"); System.out.println(resource.contentLength()); System.out.println(resource.getFilename()); Resource resource1 = context.getResource("https://www.baidu.com"); System.out.println(resource1.contentLength()); System.out.println(resource1.getURL()); Resource resource2 = context.getResource("classpath:spring.xml"); System.out.println(resource2.contentLength()); System.out.println(resource2.getURL()); 还可以一次性获取多个： Resource[] resources = context.getResources("classpath:com/zhouyu/*.class"); for (Resource resource : resources) { System.out.println(resource.contentLength()); System.out.println(resource.getFilename()); } 获取运行时环境 获取运行时环境 AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); Map systemEnvironment = context.getEnvironment().getSystemEnvironment(); System.out.println(systemEnvironment); System.out.println("======="); Map systemProperties = context.getEnvironment().getSystemProperties(); System.out.println(systemProperties); System.out.println("======="); MutablePropertySources propertySources = context.getEnvironment().getPropertySources(); System.out.println(propertySources); System.out.println("======="); System.out.println(context.getEnvironment().getProperty("NO_PROXY")); System.out.println(context.getEnvironment().getProperty("sun.jnu.encoding")); System.out.println(context.getEnvironment().getProperty("zhouyu")); 注意，可以利用 @PropertySource("classpath:spring.properties") 来使得某个properties文件中的参数添加到运行时环境中 事件发布 先定义一个事件监听器 @Bean public ApplicationListener applicationListener() { return new ApplicationListener() { @Override public void onApplicationEvent(ApplicationEvent event) { System.out.println("接收到了一个事件"); } }; } 然后发布一个事件： context.publishEvent("kkk"); 类型转化 类型转化 在Spring源码中，有可能需要把String转成其他类型，所以在Spring源码中提供了一些技术来更方便 的做对象的类型转化，关于类型转化的应用场景， 后续看源码的过程中会遇到很多。 PropertyEditor 这其实是JDK中提供的类型转化工具类 public class StringToUserPropertyEditor extends PropertyEditorSupport implements PropertyEditor { @Override public void setAsText(String text) throws IllegalArgumentException { User user = new User(); user.setName(text); this.setValue(user); } } StringToUserPropertyEditor propertyEditor = new StringToUserPropertyEditor(); propertyEditor.setAsText("1"); User value = (User) propertyEditor.getValue(); System.out.println(value); 如何向Spring中注册PropertyEditor： @Bean public CustomEditorConfigurer customEditorConfigurer() { CustomEditorConfigurer customEditorConfigurer = new CustomEditorConfigurer(); Map, Class&gt; propertyEditorMap = new HashMap&lt;&gt;(); // 表示StringToUserPropertyEditor可以将String转化成User类型，在Spring源码中，如果发现当前 对象是String，而需要的类型是User，就会使用该PropertyEditor来做类型转化 propertyEditorMap.put(User.class, StringToUserPropertyEditor.class); customEditorConfigurer.setCustomEditors(propertyEditorMap); return customEditorConfigurer; } 假设现在有如下Bean: @Component public class UserService { @Value("xxx") private User user; public void test() { System.out.println(user); } } 那么test属性就能正常的完成属性赋值 ConversionService Spring中提供的类型转化服务，它比PropertyEditor更强大 public class StringToUserConverter implements ConditionalGenericConverter { @Override public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) { return sourceType.getType().equals(String.class) &amp;&amp; targetType.getType().equals(User.class); } @Override public Set getConvertibleTypes() { return Collections.singleton(new ConvertiblePair(String.class, User.class)); } @Override public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { User user = new User(); user.setName((String)source); return user; } } DefaultConversionService conversionService = new DefaultConversionService(); conversionService.addConverter(new StringToUserConverter()); User value = conversionService.convert("1", User.class); System.out.println(value); 如何向Spring中注册ConversionService： @Bean public ConversionServiceFactoryBean conversionService() { ConversionServiceFactoryBean conversionServiceFactoryBean = new ConversionServiceFactoryBean(); conversionServiceFactoryBean.setConverters(Collections.singleton(new StringToUserConverter())); return conversionServiceFactoryBean; } TypeConverter TypeConverter 整合了PropertyEditor和ConversionService的功能，是Spring内部用的 SimpleTypeConverter typeConverter = new SimpleTypeConverter(); typeConverter.registerCustomEditor(User.class, new StringToUserPropertyEditor()); //typeConverter.setConversionService(conversionService); User value = typeConverter.convertIfNecessary("1", User.class); System.out.println(value); OrderComparator OrderComparator是Spring所提供的一种比较器，可以用来根据@Order注解或实现Ordered接口 来执行值进行笔记，从而可以进行排序。 比如： public class A implements Ordered { @Override public int getOrder() { return 3; } @Override public String toString() { return this.getClass().getSimpleName(); } } public class B implements Ordered { @Override public int getOrder() { return 2; } @Override public String toString() { return this.getClass().getSimpleName(); } } public class Main { public static void main(String[] args) { A a = new A(); // order=3 B b = new B(); // order=2 OrderComparator comparator = new OrderComparator(); System.out.println(comparator.compare(a, b)); // 1 List list = new ArrayList&lt;&gt;(); list.add(a); list.add(b); // 按order值升序排序 list.sort(comparator); System.out.println(list); // B，A } } 另外，Spring中还提供了一个OrderComparator的子类： AnnotationAwareOrderComparator，它支持用@Order来指定order值。比如： @Order(3) public class A { @Override public String toString() { return this.getClass().getSimpleName(); } } @Order(2) public class B { @Override public String toString() { return this.getClass().getSimpleName(); } } public class Main { public static void main(String[] args) { A a = new A(); // order=3 B b = new B(); // order=2 AnnotationAwareOrderComparator comparator = new AnnotationAwareOrderComparator(); System.out.println(comparator.compare(a, b)); // 1 List list = new ArrayList&lt;&gt;(); list.add(a); list.add(b); // 按order值升序排序 list.sort(comparator); System.out.println(list); // B，A } } BeanPostProcessor BeanPostProcess表示Bena的后置处理器，我们可以定义一个或多个BeanPostProcessor，比如通 过一下代码定义一个BeanPostProcessor： @Component public class ZhouyuBeanPostProcessor implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { if ("userService".equals(beanName)) { System.out.println("初始化前"); } return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { if ("userService".equals(beanName)) { System.out.println("初始化后"); } return bean; } } 一个BeanPostProcessor可以在任意一个Bean的初始化之前以及初始化之后去额外的做一些用户自 定义的逻辑，当然，我们可以通过判断beanName来进行针对性处理（针对某个Bean，或某部分 Bean）。 我们可以通过定义BeanPostProcessor来干涉Spring创建Bean的过程。 BeanFactoryPostProcessor BeanFactoryPostProcessor表示Bean工厂的后置处理器，其实和BeanPostProcessor类似， BeanPostProcessor是干涉Bean的创建过程，BeanFactoryPostProcessor是干涉BeanFactory的创 建过程。比如，我们可以这样定义一个BeanFactoryPostProcessor： @Component public class ZhouyuBeanFactoryPostProcessor implements BeanFactoryPostProcessor { @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { System.out.println("加工beanFactory"); } } 我们可以在postProcessBeanFactory()方法中对BeanFactory进行加工。 FactoryBean 上面提到，我们可以通过BeanPostPorcessor来干涉Spring创建Bean的过程，但是如果我们想一个 Bean完完全全由我们来创造，也是可以的，比如通过FactoryBean： @Component public class ZhouyuFactoryBean implements FactoryBean { @Override public Object getObject() throws Exception { UserService userService = new UserService(); return userService; } @Override public Class getObjectType() { return UserService.class; } } 通过上面这段代码，我们自己创造了一个UserService对象，并且它将成为Bean。但是通过这种方式 创造出来的UserService的Bean，只会经过初始化后，其他Spring的生命周期步骤是不会经过的，比 如依赖注入。 有同学可能会想到，通过@Bean也可以自己生成一个对象作为Bean，那么和FactoryBean的区别是 什么呢？其实在很多场景下他俩是可以替换的，但是站在原理层面来说的，区别很明显，@Bean定 义的Bean是会经过完整的Bean生命周期的。 ExcludeFilter和IncludeFilter 这两个Filter是Spring扫描过程中用来过滤的。ExcludeFilter表示排除过滤器，IncludeFilter表示包 含过滤器。 比如以下配置，表示扫描com.zhouyu这个包下面的所有类，但是排除UserService类，也就是就算 它上面有@Component注解也不会成为Bean。 @ComponentScan(value = "com.zhouyu", excludeFilters = {@ComponentScan.Filter( type = FilterType.ASSIGNABLE_TYPE, classes = UserService.class)}.) public class AppConfig { } 再比如以下配置，就算UserService类上没有@Component注解，它也会被扫描成为一个Bean。 @ComponentScan(value = "com.zhouyu", includeFilters = {@ComponentScan.Filter( type = FilterType.ASSIGNABLE_TYPE, classes = UserService.class)}) public class AppConfig { } FilterType分为： 1. ANNOTATION：表示是否包含某个注解 2. ASSIGNABLE_TYPE：表示是否是某个类 3. ASPECTJ：表示否是符合某个Aspectj表达式 4. REGEX：表示是否符合某个正则表达式 5. CUSTOM：自定义 在Spring的扫描逻辑中，默认会添加一个AnnotationTypeFilter给includeFilters，表示默认情况下 Spring扫描过程中会认为类上有@Component注解的就是Bean。 MetadataReader、ClassMetadata、 AnnotationMetadata 在Spring中需要去解析类的信息，比如类名、类中的方法、类上的注解，这些都可以称之为类的元数 据，所以Spring中对类的元数据做了抽象，并提供了一些工具类。 MetadataReader表示类的元数据读取器，默认实现类为SimpleMetadataReader。比如： public class Test { public static void main(String[] args) throws IOException { SimpleMetadataReaderFactory simpleMetadataReaderFactory = new SimpleMetadataReaderFactory(); // 构造一个MetadataReader MetadataReader metadataReader = simpleMetadataReaderFactory.getMetadataReader("com.zhouyu.service.UserService"); // 得到一个ClassMetadata，并获取了类名 ClassMetadata classMetadata = metadataReader.getClassMetadata(); System.out.println(classMetadata.getClassName()); // 获取一个AnnotationMetadata，并获取类上的注解信息 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); for (String annotationType : annotationMetadata.getAnnotationTypes()) { System.out.println(annotationType); } } } 需要注意的是，SimpleMetadataReader去解析类时，使用的ASM技术。 为什么要使用ASM技术，Spring启动的时候需要去扫描，如果指定的包路径比较宽泛，那么扫描的 类是非常多的，那如果在Spring启动时就把这些类全部加载进JVM了，这样不太好，所以使用了 ASM技术。</p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.tabs", "navigation.tabs.sticky", "content.code.annotate"], "search": "../assets/javascripts/workers/search.16e2a7d4.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\s\\-\uff0c\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version.title": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6c3db9e.min.js"></script>
      
    
  </body>
</html>